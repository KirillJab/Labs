//---------------------------------------------------------------------------

#pragma hdrstop

#include "_Rectangle.h"
//---------------------------------------------------------------------------
#pragma package(smart_init)



void _Rectangle::OnMouseDown(TStaticText* TextX, TStaticText* TextY, TStaticText* AreaText, TStaticText* PerimetrText, int X, int Y)
{
	if ((x1 < X && y1 < Y && x2 > X && y2 > Y) || (x2 < X && y2 < Y && x1 > X && y1 > Y) || (x1 < X && y2 < Y && x2 > X && y1 > Y) || (x2 < X && y1 < Y && x1 > X && y2 > Y))
	{
		xm = x2 - X;
		ym = y2 - Y;
		inFigure = true;

		PerimetrText->Caption = perimetr;
		AreaText->Caption = area;
	}
	else
	{
		x1 = X;
		y1 = Y;
		x3 = x1;
		y3 = y1;
		move = true;
		TextX->Caption = X;
		TextY->Caption = Y;
	}
}

void _Rectangle::OnMouseUp(TStaticText* TextX, TStaticText* TextY, TStaticText* AreaText, TStaticText* PerimetrText, TCanvas* Canvas, int X, int Y)
{
	if(!inFigure)
	{
		x2 = X;
		y2 = Y;
		Canvas->Pen->Color = clBlack;
		Canvas->Rectangle(x1, y1, x2, y2);
		Canvas->Rectangle((x1 + x2) / 2 - 1 , (y1 + y2) / 2 - 1, (x1 + x2) / 2 + 1, (y1 + y2) / 2 + 1);

		calc();
		TextX->Caption = x2;
		TextY->Caption = y2;
		PerimetrText->Caption = perimetr;
		AreaText->Caption = area;
	}
	move = false;
	inFigure = false;
}

void _Rectangle::OnMouseMove (TStaticText* TextX, TStaticText* TextY, TStaticText* AreaText, TStaticText* PerimetrText, TCanvas* Canvas, int X, int Y)
{
	if(move)
	{
		Canvas->Pen->Color = clWhite;
		Canvas->Rectangle(x1, y1, x3, y3);
		Canvas->Rectangle((x1 + x3) / 2 - 1 , (y1 + y3) / 2 - 1, (x1 + x3) / 2 + 1, (y1 + y3) / 2 + 1);
		x2 = X;
		y2 = Y;
		Canvas->Pen->Color = clBlack;
		Canvas->Rectangle(x1, y1, x2, y2);
		Canvas->Rectangle((x1 + x2) / 2 - 1 , (y1 + y2) / 2 - 1, (x1 + x2) / 2 + 1, (y1 + y2) / 2 + 1);
		x3 = x2;
		y3 = y2;

		calc();
		TextX->Caption = x2;
		TextY->Caption = y2;
		PerimetrText->Caption = perimetr;
		AreaText->Caption = area;
	}
	if(inFigure)
	{
		Canvas->Pen->Color = clWhite;
		Canvas->Rectangle(x1, y1, x3, y3);
		x1 = X - x2 + x1 + xm;
		y1 = Y - y2 + y1 + ym;
		x2 = X + xm;
		y2 = Y + ym;
		Canvas->Pen->Color = clBlack;
		Canvas->Rectangle(x1, y1, x2, y2);
		Canvas->Rectangle((x1 + x2) / 2 - 1 , (y1 + y2) / 2 - 1, (x1 + x2) / 2 + 1, (y1 + y2) / 2 + 1);
		x3 = x2;
		y3 = y2;
	}
}

void _Rectangle::calc()
{
	area = abs((x2 - x1) * (y2 - y1));
	perimetr = abs((x2 - x1) + (y2 - y1)) * 2;
}

void _Rectangle::rotate(TCanvas* Canvas, int ang)
{
	int x0, y0, c, x, y, xn1, xn2, xn3, xn4, yn1, yn2, yn3, yn4, X1, X2, X3, X4, Y1, Y2, Y3, Y4;
	ang = ang / 180 * 3.141590;
	x0 = (x2 + x1) / 2;
	y0 = (y2 + y1) / 2;
	x = x0 - x1;
	y = y0 - y1;
	c = sqrt(x * x + y * y);

	X1 = x1;
	X2 = x2;
	X3 = x1;
	X4 = x2;
	Y1 = y1;
	Y2 = y1;
	Y3 = y2;
	Y4 = y2;

	Canvas->Pen->Color = clRed;
	Canvas->Rectangle(X1, Y1, X4, Y4);

	xn1 = round(x0 + (X1 - x0) * cos(ang) - (Y1 - y0) * sin (ang));
	xn2 = round(x0 + (X2 - x0) * cos(ang) - (Y2 - y0) * sin (ang));
	xn3 = round(x0 + (X3 - x0) * cos(ang) - (Y3 - y0) * sin (ang));
	xn4 = round(x0 + (X4 - x0) * cos(ang) - (Y4 - y0) * sin (ang));
	yn1 = round(y0 + (X1 - x0) * sin(ang) + (Y1 - y0) * cos(ang));
	yn2 = round(y0 + (X2 - x0) * sin(ang) + (Y2 - y0) * cos(ang));
	yn3 = round(y0 + (X3 - x0) * sin(ang) + (Y3 - y0) * cos(ang));
	yn4 = round(y0 + (X4 - x0) * sin(ang) + (Y4 - y0) * cos(ang));


	/*
	xn1 = round(x0 + sin(atan(Y1/ X1) + ang) * c);
	xn2 = round(x0 + sin(atan(Y2/ X2) + ang) * c);
	xn3 = round(x0 + sin(atan(Y3/ X3) + ang) * c);
	xn4 = round(x0 + sin(atan(Y4/ X4) + ang) * c);

	yn1 = round(y0 + cos(atan(Y1/ X1) + ang) * c);
	yn2 = round(y0 + cos(atan(Y2/ X2) + ang) * c);
	yn3 = round(y0 + cos(atan(Y3/ X3) + ang) * c);
	yn4 = round(y0 + cos(atan(Y4/ X4) + ang) * c);
	*/

	Canvas->Pen->Color = clBlack;
	Canvas->MoveTo(xn1, yn1);
	Canvas->LineTo(xn2, yn2);
	Canvas->LineTo(xn3, yn3);
	Canvas->LineTo(xn4, yn4);
	Canvas->LineTo(xn1, yn1);
	Canvas->Rectangle(x0 - 1, y0 - 1, x0 + 1, y0 + 1);
}
